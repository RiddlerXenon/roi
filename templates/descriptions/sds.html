<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Стохастический диффузионный поиск</title>
    
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                tags: 'ams',
                tagSide: 'right',
                processEscapes: true,
                processEnvironments: true
            },
            svg: {
                fontCache: 'global'
            },
            startup: {
                ready: () => {
                    console.log('MathJax готов');
                    MathJax.startup.defaultReady();
                    MathJax.startup.promise.then(() => {
                        showContent();
                    });
                }
            }
        };
    </script>
    
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    
    <style>
        body {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            color: white;
            background-color: #111;
            font-family: 'Times New Roman', Times, serif;
        }
        
        .equation {
            margin: 20px 0;
            text-align: center;
            padding: 10px;
        }
        
        .algorithm {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #444;
            background-color: #1a1a1a;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border-radius: 5px;
        }
        
        .algorithm-title {
            margin-bottom: 15px;
            font-weight: bold;
            color: #fff;
            font-family: 'Times New Roman', Times, serif;
            text-align: center;
            font-size: 16px;
        }
        
        .algorithm-input, .algorithm-output, .algorithm-init {
            margin: 10px 0;
            padding: 8px 0;
            color: #ccc;
            border-bottom: 1px solid #333;
            font-family: 'Times New Roman', Times, serif;
        }
        
        .algorithm-for, .algorithm-while, .algorithm-foreach, .algorithm-return {
            margin: 5px 0;
            color: #fff;
            font-weight: bold;
            line-height: 1.4;
        }
        
        .algorithm-line {
            margin: 3px 0;
            color: #ddd;
            line-height: 1.4;
        }
        
        .algorithm-comment {
            margin: 3px 0;
            color: #888;
            font-style: italic;
            line-height: 1.4;
        }
        
        .algorithm mjx-container {
			font-family: 'Times New Roman', Times, serif !important;
			font-size: 1em !important;
			color: #fff !important;
		}
		.algorithm-math {
			display: inline-block;
			margin: 2px 0;
		}
		.algorithm-math div {
			text-align: center;
		}

        .algorithm mjx-container[display="true"] {
            display: block !important;
            margin: 0.5em 0 !important;
            text-align: left !important;
        }
        
        .algorithm mjx-container svg {
            vertical-align: baseline !important;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        p {
            text-align: justify;
            margin-bottom: 15px;
            font-size: 16px;
        }
        
        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 50px;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #666;
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }

		.references {
			border-top: none;   /* убираем верхнюю линию у блока */
			border-bottom: none; /* убираем нижнюю */
			margin-top: 0.5em;
		}

		.references ol {
			margin: 0;
			padding-left: 20px;
		}

		hr {
			border: none;
			border-top: 1px solid #444; /* более мягкий серый */
			margin: 1em 0;
		}

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <div class="loading-spinner"></div>
        Загрузка математических формул...
    </div>
    
    <div id="content" style="display: none;">
        <h1>Стохастический диффузионный поиск</h1>
        <p>Алгоритм стохастического диффузионного поиска формализуется как популяционная метаэвристика на основе коммуникационной модели с механизмом диффузии информации между агентами в дискретном времени [1, 2]. Каждый агент $i = 1, \ldots, N$ на итерации $t \in \mathbb{N}$ характеризуется состоянием $(h_i^{(t)}, s_i^{(t)}) \in \mathcal{S} \times \{0,1\}$, где $h_i^{(t)}$ — текущая гипотеза в пространстве поиска $\mathcal{S}$, а $s_i^{(t)}$ — булев индикатор активности агента. Управляющая динамика определяется двухфазным итерационным процессом с стохастической функцией частичной оценки $\phi: \mathcal{S} \times \Omega \rightarrow \{0,1\}$ и адаптивным механизмом диффузии информации между активными и неактивными агентами [1, 3].</p>
<p>Пространство поиска задается как $\mathcal{S} = [-R, R]^2 \subset \mathbb{R}^2$ с радиусом области $R > 0$. Целевая функция $f: \mathcal{S} \rightarrow \mathbb{R}_+$ подлежит максимизации. Множество тестовых компонент $\Omega$ представляет собой равномерное распределение на $\mathcal{S}$, что обеспечивает стохастическую природу оценки без необходимости глобальной нормализации функции приспособленности [2, 4].</p>
<p>Функция частичной оценки реализуется как стохастическое сравнение:</p>
<div class="equation">$$\phi _i^{(t)} = \mathbb{1} \{ f({i}^{(t)}) \geq f(\omega^{(t)}) \} \tag{1}$$</div>
<p>где $\omega^{(t)} \sim \mathcal{U}(\mathcal{S})$ — случайная точка сравнения, генерируемая независимо для каждого агента на каждой итерации. Статус активности определяется непосредственно результатом тестирования:</p>
<div class="equation">$${i}^{(t)} = \phi _i^{(t)} \tag{2}$$</div>
<p>Данный подход гарантирует, что агенты с гипотезами высокого качества имеют большую вероятность стать активными, при этом сохраняя стохастическую устойчивость алгоритма [1, 2].</p>
<p>Алгоритм состоит из двух основных фаз, выполняемых последовательно на каждой итерации: <em>фазы тестирования</em> и <em>фазы диффузии</em>. В фазе тестирования для каждого агента $i$ вычисляется новый статус активности согласно уравнению (1) с использованием текущей гипотезы $h_i^{(t)}$ и случайно выбранной тестовой компоненты $\omega^{(t)}$. Это позволяет распределенно оценить относительное качество гипотез в популяции без централизованного ранжирования [3, 4].</p>
<p>Фаза диффузии реализует адаптивный механизм обмена информацией с поддержкой мультимодальности. Множество активных агентов на итерации $t$ определяется как $\mathcal{W}^{(t)} = \{i : s_i^{(t)} = 1\}$. Правило обновления гипотез формализуется следующим образом:</p>
<p>При $|\mathcal{W}^{(t)}| = 0$ (отсутствие активных агентов) выполняется адаптивный перезапуск:</p>
<div class="equation">$${i}^{(t+1)} = \begin{cases}U(\mathcal{S}), \text{с вероятностью } p_{\text{restart}} \\ {i}^{(t)}, \text{иначе}\end{cases} \tag{3}$$</div>
<p>где $p_{\text{restart}} \in [0,1]$ — параметр интенсивности перезапуска, $U(\mathcal{S})$ — равномерное распределение на пространстве поиска.</p>
<p>При $|\mathcal{W}^{(t)}| > 0$ осуществляется стандартная диффузия от активных агентов:</p>
<div class="equation">$${i}^{(t+1)} = \begin{cases}{i}^{(t)}, \text{если } {i}^{(t)} = 1 \\ {j}^{(t)}, \text{если } {i}^{(t)} = 0, \text{ где } j \sim \mathcal{U}(\mathcal{W}^{(t)})\end{cases} \tag{4}$$</div>
<p>Данный механизм обеспечивает диффузию информации о высококачественных решениях через популяцию, одновременно предотвращая полную стагнацию при временном отсутствии приемлемых гипотез [2, 3].</p>
<p>После диффузии все агенты подвергаются стохастической мутации для обеспечения разведки:</p>
<div class="equation">$${i}^{(t+1)} \leftarrow \text{clip}_{\mathcal{S}}\left({i}^{(t+1)} + \sigma^{(t)} \cdot \mathcal{N}(0, {d})\right) \tag{5}$$</div>
<p>где $\text{clip}_{\mathcal{S}}(\cdot)$ — оператор проекции на область $\mathcal{S}$, $\mathcal{N}(0, I_d)$ — многомерное нормальное распределение, $\sigma^{(t)}$ — адаптивная дисперсия шума:</p>
<div class="equation">$$\sigma^{(t)} = \begin{cases}\sigma _0 \cdot \rho^{t}, \text{при адаптивном затухании} \\ \sigma _0, \text{при постоянной интенсивности}\end{cases} \tag{6}$$</div>
<p>с параметрами $\sigma_0 > 0$ (начальная дисперсия) и $\rho \in (0,1)$ (коэффициент затухания) [4].</p>
<p>Ключевым свойством алгоритма является формирование стационарного распределения популяции, пропорционального качеству решений. В равновесном состоянии ожидаемая концентрация агентов в окрестности точки $h \in \mathcal{S}$ определяется как:</p>
<div class="equation">$$\pi(h) \propto \mathbb{P}\{f(h) \geq f(\Omega)\} = \int_{\mathcal{S}} \mathbb{1} \{f(h) \geq f(u)\} du \tag{7}$$</div>
<p>где интегрирование ведется по равномерному распределению на $\mathcal{S}$ [1, 2].</p>
<p>Для мультимодальных функций алгоритм естественным образом поддерживает несколько кластеров агентов вокруг различных локальных максимумов. Размер кластера в окрестности локального максимума $h^* \in \mathcal{S}$ в стационарном режиме приближенно равен:</p>
<div class="equation">$$N(h^*) \approx N \cdot \frac{\pi(h^*)}{\sum_{h \in \text{Modes}} \pi(h)} \tag{8}$$</div>
<p>где $\text{Modes}$ — множество значимых локальных максимумов целевой функции [3, 4].</p>
<p>Сходимость алгоритма к глобальному оптимуму обеспечивается при выполнении условий эргодичности марковской цепи состояний популяции. Если глобальный максимум $h^*_{\text{global}}$ имеет строго большую вероятность успеха тестирования $\pi(h^*_{\text{global}}) > \pi(h)$ для всех $h \neq h^*_{\text{global}}$, то популяция асимптотически концентрируется в его окрестности с вероятностью единица [2, 3].</p>
<p>Вычислительная сложность одной итерации составляет $O(N)$, что обеспечивает масштабируемость алгоритма для больших популяций. Эффективность существенно зависит от выбора параметров $\sigma_0$, $p_{\text{restart}}$ и стратегии адаптации дисперсии шума, которые должны балансировать интенсивность разведки (exploration) и эксплуатации (exploitation) найденных решений [1, 4].</p>
<p>Конечный алгоритм формализуется следующим образом:</p>
<div class="algorithm">
<div class="algorithm-title">Алгоритм: Стохастический диффузионный поиск</div>
<div class="algorithm-input"><strong>Вход:</strong> Размер популяции $N \in \mathbb N$; пространство поиска $\mathcal S = [-R,R]^2$; целевая функция $f: \mathcal S \rightarrow \mathbb R _+$; параметры $\sigma _0 > 0$, $p_ {\text restart} \in [0,1]$, $\rho \in (0,1)$; максимальное число итераций $T$</div>
<div class="algorithm-output"><strong>Выход:</strong> Лучшая найденная гипотеза $h^*$ и её качество $f^*$</div>
<div class="algorithm-line"><strong>Инициализация:</strong></div>
<div class="algorithm-for"><strong>для</strong> $i = 1, 2, \ldots, N$ <strong>делать</strong></div>
<div class="algorithm-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="algorithm-math">${i}^{(0)} \sim \mathcal{U}(\mathcal{S})$</span></div>
<div class="algorithm-for"><strong>для</strong> $t = 0, 1, \ldots, T-1$ <strong>делать</strong></div>
<div class="algorithm-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="algorithm-math">$\mathcal{W}^{(t)} \leftarrow \emptyset$</span></div>
<div class="algorithm-comment">&nbsp;&nbsp;&nbsp;&nbsp;// Фаза тестирования</div>
<div class="algorithm-for">&nbsp;&nbsp;&nbsp;&nbsp;<strong>для</strong> $i = 1, 2, \ldots, N$ <strong>делать</strong></div>
<div class="algorithm-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Сгенерировать <span class="algorithm-math">$\omega^{(t)} \sim \mathcal{U}(\mathcal{S})$</span></div>
<div class="algorithm-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="algorithm-math">${i}^{(t)} \leftarrow \mathbb{1} \{f({i}^{(t)}) \geq f(\omega^{(t)})\}$</span></div>
<div class="algorithm-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\If{<span class="algorithm-math">${i}^{(t)} = 1$</span>}{</div>
<div class="algorithm-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="algorithm-math">$\mathcal{W}^{(t)} \leftarrow \mathcal{W}^{(t)} \cup \{i\}$</span></div>
<div class="algorithm-comment">// Фаза диффузии</div>
<div class="algorithm-line">\If{<span class="algorithm-math">$|\mathcal{W}^{(t)}| = 0$</span>}{</div>
<div class="algorithm-for"><strong>для</strong> $i = 1, 2, \ldots, N$ <strong>делать</strong></div>
<div class="algorithm-line">&nbsp;&nbsp;&nbsp;&nbsp;\If{<span class="algorithm-math">$\xi \sim \mathcal{U}(0,1) \leq p_{restart}$</span>}{</div>
<div class="algorithm-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="algorithm-math">${i}^{(t+1)} \sim \mathcal{U}(\mathcal{S})$</span></div>
<div class="algorithm-line">\Else{</div>
<div class="algorithm-line"><span class="algorithm-math">${i}^{(t+1)} \leftarrow {i}^{(t)}$</span></div>
<div class="algorithm-line">\Else{</div>
<div class="algorithm-for"><strong>для</strong> $i = 1, 2, \ldots, N$ <strong>делать</strong></div>
<div class="algorithm-line">&nbsp;&nbsp;&nbsp;&nbsp;\If{<span class="algorithm-math">${i}^{(t)} = 1$</span>}{</div>
<div class="algorithm-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="algorithm-math">${i}^{(t+1)} \leftarrow {i}^{(t)}$</span></div>
<div class="algorithm-line">\Else{</div>
<div class="algorithm-line">Выбрать <span class="algorithm-math">$j \sim \mathcal{U}(\mathcal{W}^{(t)})$</span></div>
<div class="algorithm-line"><span class="algorithm-math">${i}^{(t+1)} \leftarrow {j}^{(t)}$</span></div>
<div class="algorithm-comment">// Фаза разведки</div>
<div class="algorithm-line">Вычислить <span class="algorithm-math">$\sigma^{(t)}$</span> согласно уравнению (7)</div>
<div class="algorithm-for"><strong>для</strong> $i = 1, 2, \ldots, N$ <strong>делать</strong></div>
<div class="algorithm-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="algorithm-math">${i}^{(t+1)} \leftarrow clip_{\mathcal{S}}\left({i}^{(t+1)} + \sigma^{(t)} \cdot \mathcal{N}(0, {2})\right)$</span></div>
<div class="algorithm-line"><span class="algorithm-math">$h^* \leftarrow \arg\max_{i} f({i}^{(T)})$</span>, <span class="algorithm-math">$f^* \leftarrow f(h^*)$</span></div>
<div class="algorithm-return"><strong>вернуть</strong> $(h^*, f^*)$</div>
</div>
<p>Алгоритм стохастического диффузионного поиска представляет собой эффективный инструмент для решения задач глобальной мультимодальной оптимизации, сочетающий простоту реализации с теоретически обоснованными свойствами сходимости. Естественная поддержка параллелизации, минимальные требования к настройке параметров и способность к автоматическому обнаружению множественных оптимумов делают его привлекательной альтернативой традиционным метаэвристическим методам для широкого класса практических задач оптимизации в условиях неопределенности [1, 2, 4].</p>
<p>\noindent\hrulefill</p>
        
<hr>
<div class="references">
  <ol><li>Bishop, J.M. (1989). Stochastic searching networks. Proceedings of 1st IEE Conference on Artificial Neural Networks, London, UK, 329-331.</li><li>Nasuto, S.J., Bishop, J.M. (1999). Convergence analysis of stochastic diffusion search. Parallel Algorithms and Applications, 14(2), 89-107.</li><li>Al-Rifaie, M.M., Bishop, J.M. (2013). Stochastic diffusion search review. Paladyn, Journal of Behavioral Robotics, 4(3), 155-173.</li><li>Grech-Cini, H., McKee, G. (1993). Locating multiple optima using the stochastic diffusion search. Proceedings of the IEEE Conference on Evolutionary Computation, 259-264.</li></ol>
</div>
    </div>

    <script>
        function showContent() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('content').style.display = 'block';
            console.log('Контент отображен');
        }

        function waitForMathJax() {
            if (window.MathJax && window.MathJax.startup && window.MathJax.startup.promise) {
                window.MathJax.startup.promise.then(() => {
                    console.log('MathJax загружен');
                    showContent();
                }).catch((err) => {
                    console.log('Ошибка MathJax:', err);
                    showContent();
                });
            } else {
                setTimeout(waitForMathJax, 100);
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                if (document.getElementById('loading').style.display !== 'none') {
                    showContent();
                }
            }, 5000);
            
            waitForMathJax();
        });
    </script>
</body>
</html>